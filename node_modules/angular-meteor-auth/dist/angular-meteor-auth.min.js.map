{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-meteor-auth.min.js","webpack:///webpack/bootstrap b56fd4b164726a9ace67","webpack:///./src/angular-meteor-auth.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","name","default","angular","$Mixer","$log","$q","$$Auth","vm","arguments","length","undefined","autorun","currentUser","Meteor","user","currentUserId","userId","isLoggingIn","loggingIn","Accounts","Package","Error","errors","required","forbidden","$awaitUser","validate","_this","$bindToContext","caller","_","isFunction","deferred","$$defer","resolve","promise","stop","noop","computation","getReactively","when","then","isValid","reject","$$afterFlush","catch","error","isString","bind","fn","_fn","_len","args","Array","_key","Tracker","afterFlush","apply","concat","$waitForUser","err","debug","$requireUser","$requireValidUser","service","$rootScope","_this2","keys","forEach","k","stripped","substr","run","mixin"],"mappings":"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","file":"dist/angular-meteor-auth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteorAuth\"] = factory();\n\telse\n\t\troot[\"angularMeteorAuth\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! angular-meteor-auth v1.1.1 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteorAuth\"] = factory();\n\telse\n\t\troot[\"angularMeteorAuth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar name = 'angular-meteor.auth';\n\texports.default = name;\n\t\n\t\n\tangular.module(name, ['angular-meteor.mixer', 'angular-meteor.scope', 'angular-meteor.core', 'angular-meteor.view-model', 'angular-meteor.reactive'])\n\t\n\t/*\n\t  A mixin which provides us with authentication related methods and properties.\n\t  This mixin comes in a seperate package called `angular-meteor-auth`. Note that `accounts-base`\n\t  package needs to be installed in order for this module to work, otherwise an error will be thrown.\n\t */\n\t.factory('$$Auth', ['$Mixer', '$log', '$q', function ($Mixer, $log, $q) {\n\t  var Accounts = (Package['accounts-base'] || {}).Accounts;\n\t\n\t  if (!Accounts) {\n\t    throw Error('`angular-meteor.auth` module requires `accounts-base` package, ' + 'please run `meteor add accounts-base` before use');\n\t  }\n\t\n\t  var errors = {\n\t    required: 'AUTH_REQUIRED',\n\t    forbidden: 'FORBIDDEN'\n\t  };\n\t\n\t  function $$Auth() {\n\t    var vm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n\t\n\t    // Reset auth properties\n\t    this.autorun(function () {\n\t      // Note that we use Meteor and not Accounts since the following methods are\n\t      // not available in older versions of `accounts-base` meteor package\n\t      vm.currentUser = Meteor.user();\n\t      vm.currentUserId = Meteor.userId();\n\t      vm.isLoggingIn = Meteor.loggingIn();\n\t    });\n\t  }\n\t\n\t  // Waits for user to finish the login process. Gets an optional validation function which\n\t  // will validate if the current user is valid or not. Returns a promise which will be rejected\n\t  // once login has failed or user is not valid, otherwise it will be resolved with the current\n\t  // user\n\t  $$Auth.$awaitUser = function (validate) {\n\t    var _this = this;\n\t\n\t    validate = validate ? this.$bindToContext($Mixer.caller, validate) : function () {\n\t      return true;\n\t    };\n\t\n\t    if (!_.isFunction(validate)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t\n\t    var deferred = this.$$defer();\n\t\n\t    // If user is already logged in resolve the promise immediately to prevent an\n\t    // unnecessary computation\n\t    if (this.currentUser) {\n\t      deferred.resolve(this.currentUser);\n\t      // Keep the schema of the promise consistent\n\t      deferred.promise.stop = angular.noop;\n\t      return deferred.promise;\n\t    }\n\t\n\t    // Note the promise is being fulfilled in the next event loop to avoid\n\t    // nested computations, otherwise the outer computation will cancel the\n\t    // inner one once the scope has been destroyed which will lead to subscription\n\t    // failures. Happens mainly after resolving a route.\n\t    var computation = this.autorun(function (computation) {\n\t      if (_this.getReactively('isLoggingIn')) return;\n\t      // Stop computation once a user has logged in\n\t      computation.stop();\n\t\n\t      if (!_this.currentUser) return _this.$$afterFlush(deferred.reject, errors.required);\n\t\n\t      $q.when(validate(_this.currentUser)).then(function (isValid) {\n\t        // Resolve the promise if validation has passed\n\t        if (isValid === true) {\n\t          _this.$$afterFlush(deferred.resolve, _this.currentUser);\n\t        } else {\n\t          return $q.reject(isValid);\n\t        }\n\t      }).catch(function (isValid) {\n\t        var error = void 0;\n\t\n\t        if (_.isString(isValid) || isValid instanceof Error) {\n\t          error = isValid;\n\t        } else {\n\t          error = errors.forbidden;\n\t        }\n\t\n\t        _this.$$afterFlush(deferred.reject, error);\n\t      });\n\t    });\n\t\n\t    deferred.promise.stop = computation.stop.bind(computation);\n\t    return deferred.promise;\n\t  };\n\t\n\t  // Calls a function with the provided args after flush\n\t  $$Auth.$$afterFlush = function (fn) {\n\t    var _fn;\n\t\n\t    if (_.isString(fn)) {\n\t      fn = this[fn];\n\t    }\n\t\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    return Tracker.afterFlush((_fn = fn).bind.apply(_fn, [this].concat(args)));\n\t  };\n\t\n\t  // API v0.2.0\n\t  // Aliases with small modificatons\n\t\n\t  // No validation\n\t  // Silent error\n\t  $$Auth.$waitForUser = function () {\n\t    // Silent error\n\t    return this.$awaitUser().catch(function (err) {\n\t      $log.debug('user login has failed (' + err + ')');\n\t    });\n\t  };\n\t\n\t  // No validation\n\t  $$Auth.$requireUser = function () {\n\t    return this.$awaitUser();\n\t  };\n\t\n\t  // Full functionality\n\t  $$Auth.$requireValidUser = function () {\n\t    return this.$awaitUser.apply(this, arguments);\n\t  };\n\t\n\t  return $$Auth;\n\t}])\n\t\n\t/*\n\t  External service for syntactic sugare.\n\t  Originally created as UI-router's resolve handler.\n\t */\n\t.service('$auth', ['$rootScope', '$$Auth', function ($rootScope, $$Auth) {\n\t  var _this2 = this;\n\t\n\t  // Note that services are initialized once we call them which means that the mixin\n\t  // will be available by then\n\t  _.keys($$Auth).forEach(function (k) {\n\t    var stripped = k.substr(1);\n\t    // Not using bind() so it would be testable\n\t    _this2[stripped] = function () {\n\t      return $rootScope[k].apply($rootScope, arguments);\n\t    };\n\t  });\n\t}]).run(['$Mixer', '$$Auth', function ($Mixer, $$Auth) {\n\t  $Mixer.mixin($$Auth);\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// dist/angular-meteor-auth.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b56fd4b164726a9ace67","const name = 'angular-meteor.auth';\nexport default name;\n\nangular.module(name, [\n  'angular-meteor.mixer',\n  'angular-meteor.scope',\n  'angular-meteor.core',\n  'angular-meteor.view-model',\n  'angular-meteor.reactive'\n])\n\n/*\n  A mixin which provides us with authentication related methods and properties.\n  This mixin comes in a seperate package called `angular-meteor-auth`. Note that `accounts-base`\n  package needs to be installed in order for this module to work, otherwise an error will be thrown.\n */\n.factory('$$Auth', [\n  '$Mixer',\n  '$log',\n  '$q',\n\nfunction($Mixer, $log, $q) {\n  const Accounts = (Package['accounts-base'] || {}).Accounts;\n\n  if (!Accounts) {\n    throw Error(\n      '`angular-meteor.auth` module requires `accounts-base` package, ' +\n      'please run `meteor add accounts-base` before use'\n    );\n  }\n\n  const errors = {\n    required: 'AUTH_REQUIRED',\n    forbidden: 'FORBIDDEN'\n  };\n\n  function $$Auth(vm = this) {\n    // Reset auth properties\n    this.autorun(() => {\n      // Note that we use Meteor and not Accounts since the following methods are\n      // not available in older versions of `accounts-base` meteor package\n      vm.currentUser = Meteor.user();\n      vm.currentUserId = Meteor.userId();\n      vm.isLoggingIn = Meteor.loggingIn();\n    });\n  }\n\n  // Waits for user to finish the login process. Gets an optional validation function which\n  // will validate if the current user is valid or not. Returns a promise which will be rejected\n  // once login has failed or user is not valid, otherwise it will be resolved with the current\n  // user\n  $$Auth.$awaitUser = function(validate) {\n    validate = validate ? this.$bindToContext($Mixer.caller, validate) : () => true;\n\n    if (!_.isFunction(validate)) {\n      throw Error('argument 1 must be a function');\n    }\n\n    const deferred = this.$$defer();\n\n    // If user is already logged in resolve the promise immediately to prevent an\n    // unnecessary computation\n    if (this.currentUser) {\n      deferred.resolve(this.currentUser);\n      // Keep the schema of the promise consistent\n      deferred.promise.stop = angular.noop;\n      return deferred.promise;\n    }\n\n    // Note the promise is being fulfilled in the next event loop to avoid\n    // nested computations, otherwise the outer computation will cancel the\n    // inner one once the scope has been destroyed which will lead to subscription\n    // failures. Happens mainly after resolving a route.\n    const computation = this.autorun((computation) => {\n      if (this.getReactively('isLoggingIn')) return;\n      // Stop computation once a user has logged in\n      computation.stop();\n\n      if (!this.currentUser) return this.$$afterFlush(deferred.reject, errors.required);\n\n      $q.when(validate(this.currentUser)).then(isValid => {\n        // Resolve the promise if validation has passed\n        if (isValid === true) {\n          this.$$afterFlush(deferred.resolve, this.currentUser);\n        }\n        else {\n          return $q.reject(isValid);\n        }\n      }).catch(isValid => {\n        let error;\n\n        if (_.isString(isValid) || isValid instanceof Error) {\n          error = isValid;\n        }\n        else {\n          error = errors.forbidden;\n        }\n\n        this.$$afterFlush(deferred.reject, error);\n      });\n    });\n\n    deferred.promise.stop = computation.stop.bind(computation);\n    return deferred.promise;\n  };\n\n  // Calls a function with the provided args after flush\n  $$Auth.$$afterFlush = function(fn, ...args) {\n    if (_.isString(fn)) {\n      fn = this[fn];\n    }\n\n    return Tracker.afterFlush(fn.bind(this, ...args));\n  };\n\n  // API v0.2.0\n  // Aliases with small modificatons\n\n  // No validation\n  // Silent error\n  $$Auth.$waitForUser = function() {\n    // Silent error\n    return this.$awaitUser().catch((err) => {\n      $log.debug(`user login has failed (${err})`);\n    });\n  };\n\n  // No validation\n  $$Auth.$requireUser = function() {\n    return this.$awaitUser();\n  };\n\n  // Full functionality\n  $$Auth.$requireValidUser = function(...args) {\n    return this.$awaitUser(...args);\n  };\n\n  return $$Auth;\n}])\n\n/*\n  External service for syntactic sugare.\n  Originally created as UI-router's resolve handler.\n */\n.service('$auth', [\n  '$rootScope',\n  '$$Auth',\n\nfunction($rootScope, $$Auth) {\n  // Note that services are initialized once we call them which means that the mixin\n  // will be available by then\n  _.keys($$Auth).forEach((k) => {\n    const stripped = k.substr(1);\n    // Not using bind() so it would be testable\n    this[stripped] = (...args) => $rootScope[k](...args);\n  });\n}])\n\n.run([\n  '$Mixer',\n  '$$Auth',\n\nfunction($Mixer, $$Auth) {\n  $Mixer.mixin($$Auth);\n}]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/angular-meteor-auth.js"],"sourceRoot":""}